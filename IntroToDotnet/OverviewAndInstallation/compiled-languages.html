<h1>Compiled Languages</h1>
<p>In this course, the main server-side language is C# (pronounced "C-sharp"). One difference you will notice immediately when you start working with this language, compared to HTML or JavaScript, is that C# must first be <em>built</em> or <em>compiled</em> before it can be run. This highlights an important difference between programming languages (i.e. compiled vs. interpreted).</p>
<p>To learn about C#, we should first quickly review how programming languages developed. Let's take a brief history lesson.</p>
<p>In 1952, IBM introduced the first commercial mainframe computer, the 701. These were the days in which the logic and storage were implemented not with integrated circuits, but with vacuum tubes! Like other computing machines, this machine worked by executing a series of low-level instructions, called Assembly Language. In this era, programmers wrote their code in Assembly, which meant they had to specify every single step. As an example, in order to <em>double</em>a number we have stored in memory, one might need to do the following:</p>
<p>STORE the value of Register 0 into memory address 4011 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (so the previous value wasn't forgotten) <br>STORE&nbsp;the value of Register 1 into memory address 4012 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (so the previous value wasn't forgotten) <br>FETCH the value at memory address 3124 and put it into Register 0 &nbsp; (in our example, the value to double is located at 3124) <br>STORE&nbsp;the numerical value 2 into Register 1 <br>MULTIPLY the value in Register 0 by the value in Register 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(with MULTIPLY, the result goes into Register 0) <br>STORE&nbsp;the value of Register 0 into memory address 3124 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (overwrite the old value with the new doubled value) <br>FETCH&nbsp;the value at memory address 4011 and put it into Register 0 &nbsp; (restore the previous value of Register 0) <br>FETCH&nbsp;the value at memory address 4012 and put it into Register 1 &nbsp; (restore the previous value of Register 1)</p>
<p>Not so simple, huh? Yes, those were the bad old days of <em>hand-written assembly code</em>. That said, good programmers could 1) create certain predictable patterns of instructions, to reuse elsewhere, and 2) hand-optimize the code to make it smaller or faster (above, what if you knew the previous value for Register 1 didn't need to be remembered and restored?). Computing systems were very early in their evolution, and there was&nbsp;no&nbsp;<em>de facto</em>&nbsp;standard hardware architecture or instruction set, so each hardware manufacturer required a programmer to learn a different assembly language (within IBM, there were multiple competing hardware architectures!). So, although it was certainly possible for engineers to write code to solve some difficult problems, this would take a while, and that program could be used only in a single hardware architecture.&nbsp;</p>
<p>John Backus was one of those early assembly programmers at IBM. As often happens, he gained inspiration (in his own words) "from&nbsp;being lazy. I didn't like writing programs, and so, when I was working on the IBM 701,&nbsp;writing programs for computing missile trajectories, I started work on a programming system to make it easier to write programs."&nbsp; <a href="http://www.nbcnews.com/id/17704662/#.V9XSfJMrJE4" target="_blank">[1]</a></p>
<p>What he created was <strong>FORTRAN</strong>, a language to translate formulas&nbsp;from human-readable to machine-readable form. More importantly, along with this, he created the first <strong><em>compiler</em></strong>. This 'compiler' was a software tool that accepted source code in FORTRAN and translated it into the assembly-level statements that the computer could execute&nbsp;so that a human didn't have to craft these statements manually. Although the debate raged for decades about whether computer-generated code&nbsp;could ever outperform meticulously hand-coded solutions, it was immediately undeniable that compilers dramatically reduced the complexity of programming these computers. Eventually, compiler engineers were able to incorporate many of the lessons learned by expert hand-coders, which led to the first optimizing compilers. From that point on,&nbsp;the FORmula TRANslation language -- and other compiled languages -- were rapidly adopted.&nbsp;</p>
<h3>About Compilers</h3>
<p>In order to reduce higher-level instructions to machine-level output, a compiler parses a source file completely, in an attempt to fully understand its logic. Programming languages specify certain rules that programmers must follow, and while the compiler is doing this analysis and translation, it can also enforce these rules. This is why compiled languages might initially be frustrating, but also why compilers expose an entire class of bugs that might otherwise be difficult to diagnose.&nbsp;</p>
<p>Compilers operate on one source code file at a time, taking that file as the input, and producing an object file (.obj or .o) as the output. Another closely related software tool, called a <i>linker</i>, pulls together these different object files, as well as any additional libraries you specify, to produce the final executable.&nbsp;As with the object files, this linked output file essentially contains machine-readable code ready to run, and as such is limited to a single hardware type.&nbsp;</p>
<p>Compilation, linkage, and any subsequent activities needed to prepare the output for final use (such as compressing it and putting it into a self-extracting installer) are all considered part of the <i>build process</i>.&nbsp;Compile and link are activities that we would say occur at build time (or compile time), as opposed to later when the app executes, referred to as "run time".&nbsp;</p>
<div>
 <p>Since then, the&nbsp;linkage has become more flexible. Including to your application all of the external libraries that you need -- <em>static linking</em> -- makes your application self-sufficient but it also might make it quite large. Also, even if those external libraries are subsequently updated with important bug fixes and great new features, your application will remain tightly bound to the version that was originally linked (unless you rebuild and re-release a new version of your app).&nbsp;</p>
 <p>This desire for more flexibility led to the concept of&nbsp;<em>dynamic linkage</em>, where certain linkages are deferred from build time into run time. To this day you still see a large number of .dll files (dynamic link libraries) used by applications and operating systems, and these servers to make apps smaller and allow companies to update their software in much smaller chunks.&nbsp;</p>
</div>
