<h1>Object Abstraction</h1>
<p>In C# we have already&nbsp;lightly seen the idea of being abstract with Lists in which we provide a type of object for the list values.&nbsp;This allows lists to be more flexible as a class for accepting various types for its methods to deal with. We have also seen this idea of abstraction with class inheritance and polymorphism, where multiple classes such as Monkey and&nbsp;Bear that inherit from a similar parent class of Animal can both be treated as that more generic parent class. Abstraction with C# when dealing with classes is quite important to allow flexibility while also providing structure to how various objects are related. This could essentially be thought of as grouping these objects. Other than inheritance from a parent class, there are a few additional techniques for adding generic groupings to objects.</p>
<h2>Interfaces</h2>
<p>In C# there is no way to inherit from multiple sources. Sometimes, though, you might want to be able to group objects with different&nbsp;inheritance&nbsp;so that they&nbsp;can be&nbsp;passed the same parameter. &nbsp;The way to do this is to implement an interface that a class implements. An interface defines the actions and properties a class must have. In doing this, it is important to note it only puts a requirement on the existence of these&nbsp;properties and&nbsp;methods,&nbsp;rather than their implementation.&nbsp;From there, any class that implements an interface&nbsp;<strong>MUST</strong>&nbsp;still define&nbsp;each of these methods and fields.</p>
<pre data-language="csharp" class=" code-toolbar language-csharp"><code class="  language-csharp">public interface CanRun
{
    // Anything that implements the CanRun interface must 
    // implement a 'Run()' method that returns an integer.
    int Run();
}
// Therefore, this class must have a Run() function in it!
public class Goat : CanRun
{
    public int Run()
    {
       Console.WriteLine("I'm a goat, and you betcha I can run....");
       return 5;
    }
}
// You can have inheritance as well as interfaces at the same time! 
public class Bird
{
    // Most birds don't run!!!
}
// An ostrich, however, is a bird AND it runs!
// Note: always specify inheritance first, followed by interfaces (there may be multiple)
public class Ostrich: Bird, CanRun
{
    public int Run()
    {
        Console.WriteLine("I'm a running bird...crazy, right?");
        return -16;
        // Why does an Ostrich return -16 for this function?
        // Scientists Have been working on this very problem for years. Let's move on. 
    }
}
// Both can now be treated as objects of type CanRun
CanRun obj1 = new Ostrich();
CanRun obj2 = new Goat();
</code><div class="toolbar"></div></pre>
<h4>Collections and the IEnumerable Interface</h4>
<p>One such interface that we have been working with for a while now and not even realized is the IEnumerable interface which all collections conform to. The IEnumerable interface&nbsp;requires that anything implementing it have a defined method for iterating through the collection one object at a time. This is exactly what a foreach loop makes use of that enables us&nbsp;to iterate through both lists and dictionaries in a similar fashion.&nbsp;</p>
<h2>Abstract Classes</h2>
<p>If we intend to build a class&nbsp;only for&nbsp;the&nbsp;purpose of inheriting from it and never intend to instantiate an object of it, that class is better off being created as an abstract class. An abstract class has all the same features as the classes we have been working with up to this point, but we can not instantiate objects for it unless using it during inheritance. This provides a clear point of abstraction for all classes that then inherit from it. All that is required for making a class abstract is providing the <code>abstract</code> keyword in its declaration</p>
<pre data-language="csharp" class=" code-toolbar language-csharp"><code class="  language-csharp">public abstract class Animal
{
    public string[] characteristics {get; set;}
    
    //No reason making the constructor public since it can not be
    //Invoked other than from a class inheriting from this class
    protected Animal()
    {
        characteristics = { 
              "Multicellular", 
              "Eukaryotic Cell Structure",
              "Specialized Tissues",
              "Heterotrophs",
              "Nervous System" };
    }
}
</code><div class="toolbar"></div></pre>
<h2>Recap</h2>
<p>All of these concepts together round-out&nbsp;the core concepts of OOP when working with C#. A final example of this all presented together might be a Navy&nbsp;Lieutenant who is a F-18 pilot. This character is a NavyLieutenant, a class that would inherit from the abstract class NavyOfficer (A Class&nbsp;which&nbsp;we would never&nbsp;make an&nbsp;object from). Our NavyLieutenant can perform all the actions of being a pilot and therefore implements the Pilot interface. This NavyLieutenant can also&nbsp;perform all the actions associated with being a F-18Pilot and implements the F-18Pilot Interface as well.</p>
